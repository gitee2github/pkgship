#!/bin/bash
SYS_PATH=/etc/pkgship
OUT_PATH=/home/pkgusers/uswgi
LOGROTATE_FILE=/etc/logrotate.d/pkgship
OPERATION=$1
SERVICE_TYPE=$2
MEM_THRESHOLD='700'
MEM_FREE=$(free -m | grep "Mem" | awk '{print $7}')

function check_user() {
  echo "[INFO] start to check execution user"
  user=$(id | awk '{print $2}' | cut -d = -f 2)
  if [ "$user" == "0(root)" ] || [[ "$user" =~ "pkgshipuser" ]]; then
    echo "[INFO] check execution user ok"
  else
    echo "[ERROR] current user is not root or pkgshipuser,Please switch user."
    exit 1
  fi
}

function check_input() {
  if [ -z ${OPERATION} ] || [ ${OPERATION} != "start" -a ${OPERATION} != "stop" ]; then
    echo "[ERROR] input parameter error, usages: pkgshipd start|stop [selfpkg]"
    exit 1
  fi

  if [ "X${SERVICE_TYPE}" = "X" ]; then
    SERVICE_TYPE="selfpkg"
  elif [ ${SERVICE_TYPE} != "selfpkg" ]; then
    echo "[ERROR] Can not phase the input of ${SERVICE_TYPE}!!!"
    exit 1
  fi
}

function check_memory() {
  echo "[INFO] start to check memory"
  if [ ${OPERATION} = "start" ]; then
    if [ $MEM_FREE -lt $MEM_THRESHOLD ]; then
      echo "[ERROR] pkgship tool does not support memory less than ${MEM_THRESHOLD} MB."
      exit 1
    fi
  fi
  echo "[INFO] check memory ok"
}

function check_config_file() {
  echo "[INFO] start to check config file"
  # validate package.ini is exist
  if [ ! -f "$SYS_PATH/package.ini" ]; then
    echo "[ERROR] $SYS_PATH/package.ini dose not exist!!!"
    exit 1
  fi

  # check and create uswgi out path
  if [ ! -d "$OUT_PATH" ]; then
    mkdir -p $OUT_PATH
  fi
  echo "[INFO] check config file ok"
}

function check_config_param() {
  echo "[INFO] start to check validation of config parameter."
  check_null
  # check query port and ip
  echo "[INFO] Check the IP and port of the service query"
  query_port=$(get_config "query_port")
  query_ip_addr=$(get_config "query_ip_addr")
  if [ -z "${query_port}" ] || [ -z "${query_ip_addr}" ]; then
    echo "[ERROR] CAN NOT find config name 'query_port' or 'query_ip_addr' in: $SYS_PATH/package.ini,
    Please check the file."
    exit 1
  fi
  check_addr $query_ip_addr $query_port
  echo "[INFO] IP addresses are all valid."

  echo "[INFO] Check validation of numbers."
  num_vars=(buffer-size http-timeout harakiri)
  for var in ${num_vars[@]}; do
    value=$(get_config $var)
    if [[ -z "$value" ]]; then
      echo "[ERROR] CAN NOT find config name $var in: $SYS_PATH/package.ini, Please check the file."
      exit 1
    fi
    check_num ${value} ${var}
  done
  echo "[INFO] All numbers are valid."

  echo "[INFO] Check validation of words."
  log_level=$(get_config "log_level")
  check_word "log_level" "INFO|DEBUG|WARNING|ERROR|CRITICAL" $log_level
  echo "[INFO] All words are valid."

  echo "[INFO] check config parameter ok."
}

function check_addr() {
  ip=$1
  port=$2
  ret=1
  # check ip
  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    ip=(${ip//\./ })
    [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]]
    ret=$?
  fi
  if [ $ret -ne 0 ]; then
    echo "[ERROR] Invalid ip of $ip"
    exit 1
  fi
  # check port
  check_num ${port-"port"} "port"
  if [[ $port -gt 65534 || $port -lt 1025 ]]; then
    echo "[ERROR] Invalid port of $port"
    exit 1
  fi
}

function check_null() {
  list=$(cat $SYS_PATH/package.ini | grep -E ^[a-z_-]+= | awk -F '=' '{if($2 == "")print $1}')
  num=0
  for val in $list; do
    num=$(($num + 1))
  done
  if [ $num -gt 0 ]; then
    echo "[ERROR] The value of below config names is None in: $SYS_PATH/package.ini, Please check these parameters:"
    for val in $list; do
      echo $val
    done
    exit 1
  fi
}

function check_num() {
  result=$(echo $1 | grep '^[[:digit:]]*$')
  if [ -z "${result}" ]; then
    echo "[ERROR] $2 should be a number."
    exit 1
  fi
}

function check_word() {
  if [ -z $3 ]; then
    echo "[ERROR] The value of below config names is None in: $SYS_PATH/package.ini, Please check these parameters: $1"
    exit 1
  fi

  result=$(echo $3 | grep -wE "$2")
  if [ -z "${result}" ]; then
    echo "[ERROR] $1 should be $2."
    exit 1
  fi
}

function get_config() {
  cat $SYS_PATH/package.ini | grep -E ^$1 | sed 's/[[:space:]]//g' | awk 'BEGIN{FS="="}{print $2}'
}

function create_config_file() {
  echo "[INFO] start to create uwsgi file"
  query_port=$(get_config "query_port")
  query_ip_addr=$(get_config "query_ip_addr")
  daemonize=$(get_config "daemonize")
  buffer_size=$(get_config "buffer-size")
  http_timeout=$(get_config "http-timeout")
  harakiri=$(get_config "harakiri")
  uwsgi_file_path=$(find /usr/lib/ -name "packageship" | head -n 1)
  echo "[INFO] run packageship under path: $uwsgi_file_path"

  if [[ -z "$daemonize" ]] || [[ -z "$buffer_size" ]] || [[ -z "$http_timeout" ]] || [[ -z "$harakiri" ]]; then
    echo "[ERROR] CAN NOT find  all config name in: $SYS_PATH/package.ini, Please check the file."
    echo "[ERROR] The following config name is needed: daemonize, buffer_size, harakiri and http-timeout."
    exit 1
  fi
  if [ -z "$uwsgi_file_path" ]; then
    echo "[ERROR] CAN NOT find the uwsgi file path under: /usr/lib/"
    exit 1
  fi

  echo "[INFO] selfpkg.ini is saved to: $OUT_PATH/selfpkg.ini"
  echo "[uwsgi]
http=$query_ip_addr:$query_port
module=packageship.selfpkg
uwsgi-file=$uwsgi_file_path/selfpkg.py
callable=app
buffer-size=$buffer_size
pidfile=$OUT_PATH/selfpkg.pid
http-timeout=$http_timeout
harakiri=$harakiri
enable-threads=true
daemonize=$daemonize" >$OUT_PATH/selfpkg.ini
  chmod 750 $OUT_PATH/selfpkg.ini
  echo "[INFO] create uwsgi file ok"
}

function create_logrotate_file() {
  echo "[INFO] start to create logrotate config file"

  if [ ! -f ${LOGROTATE_FILE} ]; then
    echo "[ERROR] logrotate config file is not exist"
    exit 1
  fi
  log_path=$(get_config "log_path")
  echo "${log_path}/pkgship.log {
        daily
        missingok
        rotate 30
        dateext
        size = 100k
        missingok
        create 644 root root
        compress
        copytruncate
        notifempty
}" >${LOGROTATE_FILE}
  echo "[INFO] create logrotate config file success"

}

function start_service() {
  if [ "$(ps aux | grep "uwsgi" | grep "${SERVICE_TYPE}.ini")" != "" ]; then
    echo "[WARNING] ${SERVICE_TYPE} service is running, please STOP it first."
  else
    cd "$uwsgi_file_path"
    uwsgi -d --ini $OUT_PATH/${SERVICE_TYPE}.ini
    echo "[INFO] START uwsgi service: ${SERVICE_TYPE}.ini"
  fi
}

function stop_service() {
  if [ ! -f "$OUT_PATH/${SERVICE_TYPE}.pid" ]; then
    echo "[ERROR] STOP service FAILED, $OUT_PATH/${SERVICE_TYPE}.pid dose not exist."
    echo "[ERROR] Please stop it manually by using [ps -aux] and [uwsgi --stop #PID]"
    exit 1
  fi

  pid=$(cat $OUT_PATH/${SERVICE_TYPE}.pid)
  if [ "$(ps aux | awk 'BEGIN{FS=" "}{if ($2=='$pid') print $0}' | grep "${SERVICE_TYPE}.ini")" != "" ]; then
    uwsgi --stop $OUT_PATH/${SERVICE_TYPE}.pid
    echo "[INFO] STOP uwsgi service: ${SERVICE_TYPE}.ini"
  else
    echo "[WARNING] STOP service [FAILED], Please START the service first."
  fi
}

function start_or_stop_service() {
  if [ "${OPERATION}" = "start" ]; then
    start_service
    echo "===The run log is saved into: $(get_config "daemonize")==="
  elif [ "${OPERATION}" = "stop" ]; then
    stop_service
    echo "===The run log is saved into: $(get_config "daemonize")==="
  else
    echo "Usages: sh pkgshipd.sh start|stop [manage|selfpkg]"
  fi
}

function check_redis_installed() {
  echo "[INFO] Redis check start"
  # check package.ini config
  redis_ip=$(get_config "redis_host")
  redis_port=$(get_config "redis_port")
  if [ -z "${redis_ip}" ] || [ -z "${redis_port}" ]; then
    echo "[Warning] Can not find config name 'redis_host' or 'redis_port' in: $SYS_PATH/package.ini,Please check the file"
    echo "If you have installed REDIS, Please set correct 'redis_hos' and 'redis_port' values and re-execute the startup script "
    echo "If you have not installed REDIS, Please set 'redis_host: 127.0.0.1' and 'redis_port: 9200' and execute the automatic installation script '${SYS_PATH}/auto_install_es.sh' under the root user"
  fi
  # check whether to install Redis
  host="127.0.0.1"
  port=6379
  python_command="import redis
try:
    response = redis.Redis(host='$host',
                           port="$port")
    print(response.ping())
except redis.ConnectionError:
    print(False)"
  result=$(python -c "$python_command")

  if [ "${result}" = "False" ]; then
    echo "========================================================================="
    echo "[Warning] Redis connection FAILED."
    echo "[Warning] The following reason may cause failed:"
    echo "[Warning] 1. not installed Redis or the Redis configuration is incorrect."
    echo "[Warning] 2. the Redis configuration is incorrect."
    echo "If you need to install, please execute the automatic installation script '${SYS_PATH}/auto_install_es.sh' under the root user"
    echo "[Warning] 3. The Redis you connected is set to access with a password and cannot be used."
    echo "Please cancel the password or connect another Redis without a password"
  fi
  echo "[INFO] Redis check ok"
}

function check_es_installed() {
  echo "[INFO] Elasticsearch check start"
  # check package.ini config
  es_ip=$(get_config "database_host")
  es_port=$(get_config "database_port")
  if [ -z "${es_ip}" ] || [ -z "${es_port}" ]; then
    echo "[ERROR] Can not find config name 'database_host' or 'database_port' in: $SYS_PATH/package.ini,Please check the file"
    echo "If you have installed ES, Please set correct 'database_host' value and 'database_port' value and re-execute 'pkgshipd start' "
    echo "If you have not installed ES, please execute the automatic installation script '${SYS_PATH}/auto_install_es.sh' under the root user "
    exit 1
  fi
  # check whether to install Elasticsearch
  visit_es_response=$(curl -s -XGET http://"${es_ip}":"${es_port}")
  if [ -z "${visit_es_response}" ]; then
    echo "========================================================================="
    echo "[ERROR] You have not installed Elasticsearch or the Elasticsearch configuration is incorrect."
    echo "If you need to install, please execute the automatic installation script '${SYS_PATH}/auto_install_es.sh' under the root user"
    exit 1
  fi
  # check whether a password is set
  if [[ $visit_es_response =~ "authentication" ]]; then
    echo "The ES you installed is set to access with a password and cannot be used."
    echo "Please cancel the password or install another ES without a password"
    exit 1
  fi
  # check elasticsearch version
  es_version=$(echo "${visit_es_response}" | grep "number" | awk -F'"' '{print $4}')
  if [ "${es_version}" != "7.10.1" ]; then
    echo "========================================================================="
    echo "[WARNING] The Elasticsearch version you installed is not the recommended version 7.10.1,which may cause it to be unusable."
    read -p "Do you want to continue (y/n):" version_operation
    if [ "${version_operation}" = "n" ] || [ "${version_operation}" = "N" ]; then
      echo "[ERROR] You have terminated the execution"
      exit 1
    fi
  fi

  echo "[INFO] Elasticsearch check ok"
}

function main() {
  #check user
  check_user
  # check input
  check_input
  # check free memory
  check_memory
  # check uwsgi and package.ini
  check_config_file
  # check config parameter
  if [ "${OPERATION}" = "start" ]; then
    check_config_param
    # create uwsgi files
    create_config_file
    # check redis installed
    check_redis_installed
    # check es installed
    check_es_installed
    # create logrotate
    create_logrotate_file
  fi
  #star or stop service
  start_or_stop_service
}

main
